
import { CardRepository } from '@/repositories/cardRepository';
import { CardStorageService } from './cardStorage';
import type { CardData } from '@/hooks/card-editor/types';

export interface MigrationResult {
  success: boolean;
  totalCards: number;
  migratedCount: number;
  failedCount: number;
  errors: Array<{
    cardId: string;
    cardTitle: string;
    error: string;
    validationDetails?: any;
  }>;
  warnings: string[];
  detailedReport: any;
}

export interface CardValidationResult {
  isValid: boolean;
  errors: string[];
  warnings: string[];
}

export class CardMigrationService {
  // Enhanced card validation with detailed error reporting
  static validateCard(card: CardData): CardValidationResult {
    const errors: string[] = [];
    const warnings: string[] = [];

    console.log(`üîç Validating card: ${card.title || 'Untitled'} (${card.id})`);

    // Required fields validation
    if (!card.title?.trim()) {
      errors.push('Card title is required and cannot be empty');
    }
    
    if (!card.id) {
      warnings.push('Card ID is missing, will be generated by database');
    }

    // Validate rarity with detailed mapping info
    const validRarities = ['common', 'uncommon', 'rare', 'ultra-rare', 'legendary'];
    if (card.rarity && !validRarities.includes(card.rarity)) {
      console.warn(`‚ö†Ô∏è Invalid rarity "${card.rarity}" for card "${card.title}"`);
      warnings.push(`Invalid rarity "${card.rarity}", will be mapped to common`);
    }

    // Validate visibility
    const validVisibilities = ['public', 'private', 'shared'];
    if (card.visibility && !validVisibilities.includes(card.visibility)) {
      warnings.push(`Invalid visibility "${card.visibility}", will be set to private`);
    }

    // Validate arrays and objects
    if (card.tags && !Array.isArray(card.tags)) {
      errors.push('Tags must be an array');
    }

    if (card.design_metadata && typeof card.design_metadata !== 'object') {
      warnings.push('design_metadata should be an object, will be reset to empty object');
    }

    // Check for common problematic fields
    if (card.publishing_options && typeof card.publishing_options !== 'object') {
      warnings.push('publishing_options should be an object, will be reset to defaults');
    }

    console.log(`‚úÖ Validation complete for "${card.title}": ${errors.length} errors, ${warnings.length} warnings`);

    return {
      isValid: errors.length === 0,
      errors,
      warnings
    };
  }

  // Enhanced card preparation with better error handling
  static prepareCardForDatabase(card: CardData, userId: string): any {
    console.log(`üîß Preparing card for database: ${card.title}`);

    // Map rarity to database enum with fallback
    const rarityMap: Record<string, string> = {
      'common': 'common',
      'uncommon': 'uncommon', 
      'rare': 'rare',
      'ultra-rare': 'legendary',
      'legendary': 'legendary'
    };

    const dbRarity = rarityMap[card.rarity] || 'common';
    if (card.rarity && !rarityMap[card.rarity]) {
      console.warn(`üìù Mapped unknown rarity "${card.rarity}" to "common"`);
    }

    const preparedCard = {
      title: card.title?.trim() || 'Untitled Card',
      description: card.description?.trim() || '',
      creator_id: userId,
      image_url: card.image_url || null,
      thumbnail_url: card.thumbnail_url || null,
      rarity: dbRarity,
      tags: Array.isArray(card.tags) ? card.tags : [],
      design_metadata: (card.design_metadata && typeof card.design_metadata === 'object') ? card.design_metadata : {},
      is_public: card.visibility === 'public',
      visibility: card.visibility || 'private',
      marketplace_listing: card.publishing_options?.marketplace_listing || false,
      print_available: card.publishing_options?.print_available || false,
      series: card.series || null,
      verification_status: 'pending'
    };

    console.log(`‚úÖ Card prepared for database:`, {
      title: preparedCard.title,
      rarity: preparedCard.rarity,
      hasImage: !!preparedCard.image_url,
      tagsCount: preparedCard.tags.length
    });

    return preparedCard;
  }

  // Enhanced preview with better reporting
  static async previewMigration(userId: string): Promise<{
    report: any;
    validCards: number;
    invalidCards: number;
    validationIssues: Array<{
      cardId: string;
      cardTitle: string;
      errors: string[];
      warnings: string[];
    }>;
  }> {
    console.log('üîç Starting migration preview...');
    
    // First consolidate storage
    CardStorageService.consolidateStorage();
    
    const report = CardStorageService.getStorageReport();
    const allCards = CardStorageService.getAllCards();
    
    console.log(`üìä Found ${allCards.length} cards to analyze`);
    
    let validCards = 0;
    let invalidCards = 0;
    const validationIssues: Array<{
      cardId: string;
      cardTitle: string;
      errors: string[];
      warnings: string[];
    }> = [];

    for (const card of allCards) {
      const validation = this.validateCard(card);
      
      if (validation.isValid) {
        validCards++;
      } else {
        invalidCards++;
      }

      if (validation.errors.length > 0 || validation.warnings.length > 0) {
        validationIssues.push({
          cardId: card.id || 'unknown',
          cardTitle: card.title || 'Untitled',
          errors: validation.errors,
          warnings: validation.warnings
        });
      }
    }

    console.log(`üìà Preview complete: ${validCards} valid, ${invalidCards} invalid`);

    return {
      report,
      validCards,
      invalidCards,
      validationIssues
    };
  }

  // Enhanced migration execution with detailed error reporting
  static async executeMigration(userId: string): Promise<MigrationResult> {
    const result: MigrationResult = {
      success: false,
      totalCards: 0,
      migratedCount: 0,
      failedCount: 0,
      errors: [],
      warnings: [],
      detailedReport: {}
    };

    try {
      console.log('üöÄ Starting enhanced card migration...');
      
      // First consolidate storage
      const consolidation = CardStorageService.consolidateStorage();
      if (consolidation.errors.length > 0) {
        result.warnings.push(...consolidation.errors);
      }

      const allCards = CardStorageService.getAllCards();
      result.totalCards = allCards.length;

      console.log(`üì¶ Processing ${allCards.length} cards for migration`);

      if (allCards.length === 0) {
        result.success = true;
        result.warnings.push('No cards found to migrate');
        return result;
      }

      // Process each card with detailed logging
      for (let i = 0; i < allCards.length; i++) {
        const card = allCards[i];
        console.log(`\nüîÑ Processing card ${i + 1}/${allCards.length}: ${card.title || 'Untitled'}`);
        
        try {
          // Enhanced validation
          const validation = this.validateCard(card);
          if (!validation.isValid) {
            const errorDetail = {
              cardId: card.id || 'unknown',
              cardTitle: card.title || 'Untitled',
              error: `Validation failed: ${validation.errors.join(', ')}`,
              validationDetails: validation
            };
            result.errors.push(errorDetail);
            result.failedCount++;
            console.error(`‚ùå Validation failed for "${card.title}":`, validation.errors);
            continue;
          }

          if (validation.warnings.length > 0) {
            result.warnings.push(`${card.title}: ${validation.warnings.join(', ')}`);
            console.warn(`‚ö†Ô∏è Warnings for "${card.title}":`, validation.warnings);
          }

          // Prepare for database with enhanced logging
          const dbCard = this.prepareCardForDatabase(card, userId);
          console.log(`üíæ Attempting database insertion for "${card.title}"`);
          
          // Attempt database insertion with timeout and proper error handling
          let dbResult: any;
          try {
            dbResult = await Promise.race([
              CardRepository.createCard(dbCard),
              new Promise((_, reject) => 
                setTimeout(() => reject(new Error('Database timeout after 10 seconds')), 10000)
              )
            ]);
          } catch (timeoutError) {
            const errorDetail = {
              cardId: card.id || 'unknown',
              cardTitle: card.title || 'Untitled',
              error: timeoutError instanceof Error ? timeoutError.message : 'Database operation timeout',
              validationDetails: validation
            };
            result.errors.push(errorDetail);
            result.failedCount++;
            console.error(`‚ùå Database timeout for "${card.title}"`);
            continue;
          }
          
          if (dbResult && typeof dbResult === 'object' && 'id' in dbResult) {
            result.migratedCount++;
            console.log(`‚úÖ Successfully migrated "${card.title}" (DB ID: ${(dbResult as any).id})`);
          } else {
            const errorDetail = {
              cardId: card.id || 'unknown',
              cardTitle: card.title || 'Untitled',
              error: 'Database insertion failed - no result returned',
              validationDetails: validation
            };
            result.errors.push(errorDetail);
            result.failedCount++;
            console.error(`‚ùå Database insertion returned null for "${card.title}"`);
          }
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : 'Unknown error';
          const errorDetail = {
            cardId: card.id || 'unknown',
            cardTitle: card.title || 'Untitled',
            error: errorMessage,
            validationDetails: undefined
          };
          result.errors.push(errorDetail);
          result.failedCount++;
          console.error(`‚ùå Migration error for "${card.title}":`, error);
        }
      }

      result.success = result.migratedCount > 0;
      result.detailedReport = {
        processedAt: new Date().toISOString(),
        userRequested: userId,
        consolidationWarnings: consolidation.errors
      };
      
      console.log(`\nüéØ Migration completed:`, {
        total: result.totalCards,
        success: result.migratedCount,
        failed: result.failedCount,
        successRate: `${((result.migratedCount / result.totalCards) * 100).toFixed(1)}%`
      });

      // Log detailed error summary
      if (result.errors.length > 0) {
        console.group('‚ùå Failed Card Details:');
        result.errors.forEach((error, index) => {
          console.log(`${index + 1}. ${error.cardTitle} (${error.cardId}): ${error.error}`);
        });
        console.groupEnd();
      }
      
      return result;
    } catch (error) {
      console.error('üí• Migration system error:', error);
      result.errors.push({
        cardId: 'system',
        cardTitle: 'Migration System',
        error: error instanceof Error ? error.message : 'Unknown system error',
        validationDetails: undefined
      });
      return result;
    }
  }
}
